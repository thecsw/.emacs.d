;;; el-job-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))



;;; Generated autoloads from el-job.el

(register-definition-prefixes "el-job" '("el-job"))


;;; Generated autoloads from el-job-child.el

(register-definition-prefixes "el-job-child" '("el-job-child--"))


;;; Generated autoloads from el-job-ng.el

(autoload 'el-job-ng-run "el-job-ng" "\
Use asynchronous subprocesses to map FUNCALL-PER-INPUT to INPUTS.

At a glance:

1. Split INPUTS into sub-lists up to `el-job-ng-max-cores', and spawn an
   Emacs subprocess for each.

2. In each subprocess, set INJECT-VARS, load REQUIRE, eval EVAL, then
   loop over its sub-list of INPUTS, calling FUNCALL-PER-INPUT
   on each item and collecting the return values.

3. When all processes finish, append the lists of return values and pass
   that to CALLBACK (funcalled precisely once) in the main process.
   In other words, CALLBACK should be expected to receive one list that
   is equal in length to INPUTS.

Details:
- INJECT-VARS is an alist of symbols and values to pass to `set'.
  It has some default members, including `load-path'.
- REQUIRE is a list of symbols like `features'.
- EVAL is a list of quoted forms.
- FUNCALL-PER-INPUT must be a symbol with a function definition,
  not an anonymous lambda.
  It is passed two arguments: the current item, and the remaining items.
  (You probably will not need the second argument.)

Finally, ID is an optional symbol.  It has two effects:
- Automatically cancel a running job with the same ID, before starting.
- Use benchmarks from previous runs to better balance the INPUTS split.

ID can also be passed to these helpers:
- `el-job-ng-await'
- `el-job-ng-ready-p'
- `el-job-ng-busy-p'
- `el-job-ng-kill'
- `el-job-ng-kill-keep-bufs'
- `el-job-ng-processes'
- `el-job-ng-stderr'

(fn &key ID INJECT-VARS REQUIRE EVAL INPUTS FUNCALL-PER-INPUT CALLBACK)")
(register-definition-prefixes "el-job-ng" '("el-job-ng-"))


;;; Generated autoloads from el-job-old.el

(autoload 'el-job-old-launch "el-job-old" "\
Run FUNCALL-PER-INPUT in one or more headless Elisp processes.
Then merge the return values (lists of N lists) into one list
(of N lists) and pass it to CALLBACK.

i.e. each subprocess may return lists like

process 1: ((city1 city2) (road1) (museum1 museum2))
process 2: ((city3 city4 city5) (road2) (museum3))
process 3: ...

but at the end, these lists are merged into a single list shaped just like
any one of those above, with the difference that the sublists have more
elements:

((city1 city2 city3 city4 city5)
  (road1 road2)
  (museum1 museum2 museum3))

which is why it's important that FUNCALL-PER-INPUT always returns a list
with a fixed-in-advance number of sub-lists, enabling this merge.
These sub-lists are allowed to be empty, i.e. nil, but not absent.

The fixed-in-advance number can also be zero, i.e. FUNCALL-PER-INPUT may
be designed to always return nil.


FUNCALL-PER-INPUT is a symbol known to be defined in some Emacs Lisp
file as a function of one argument.

Usually, it would be a function you have written yourself, and you pass
LOAD-FEATURES to indicate where to find that Emacs Lisp file, plus any
dependencies not built into Emacs.

LOAD-FEATURES is a list of symbols like those in `features'; the files
in question should end with a `provide' call on the same symbols.

The subprocesses do not inherit `load-path', it is the current Emacs
process that locates files (by inspecting `load-history', via
`el-job-old--ensure-compiled-lib'), then gives them to each subprocess.

Tip: To let them inherit `load-path' anyway, add it to INJECT-VARS.


INPUTS is a list that will be split by up to the output of
`num-processors', and this determines how many subprocesses will spawn.

INPUTS can also be a function that returns a list.  In this case, the
function is deferred until needed, possibly saving on compute.

If INPUTS is a function and it returns nil, do nothing and return the
symbol `inputs-were-empty'.


The subprocesses have no access to current Emacs state.  The only way
they can affect current state, is if FUNCALL-PER-INPUT returns data,
which is then handled by CALLBACK function in the current Emacs, as
described earlier.

Emacs stays responsive to user input up until all subprocesses finish,
which is when their results are merged and CALLBACK is executed.

CALLBACK receives two arguments: the results as mentioned before, and the
job object.  The latter is mainly useful to check timestamps,
which you can get from this form:

    (el-job-old-timestamps JOB)

EVAL is a list of forms to eval once, just after loading LOAD-FEATURES.


ID is a symbol identifying this job.  It has several purposes:

- Prevent launching the same job twice, if the last invocation is not
  done yet.  Argument IF-BUSY regulates what happens instead.

- Allow repeated calls on the same inputs to optimize how those inputs
  are split, thanks to benchmarks from previous calls.


IF-BUSY comes into effect when the previous launch with the same ID is
still at work.  IF-BUSY may take on one of three symbols:

- `wait' (default): append the inputs to a queue, to be handled
                     after all children are ready
- `noop': do nothing, drop inputs
- `takeover': kill and restart with the new inputs

For debugging, see these commands:
- `el-job-old-cycle-debug-level'
- `el-job-old-show-info'
- `el-job-old-kill-all'

(fn &key ID (IF-BUSY \\='wait) LOAD-FEATURES INJECT-VARS EVAL INPUTS FUNCALL-PER-INPUT CALLBACK)")
(register-definition-prefixes "el-job-old" '("el-job-old-"))


;;; Generated autoloads from el-job-old-child.el

(register-definition-prefixes "el-job-old-child" '("el-job-old-child--"))

;;; End of scraped data

(provide 'el-job-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; el-job-autoloads.el ends here
